(window.webpackJsonp=window.webpackJsonp||[]).push([[288],{967:function(v,_,l){"use strict";l.r(_);var i=l(20),n=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"作业-整理自己的数据结构和脑图"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#作业-整理自己的数据结构和脑图"}},[v._v("#")]),v._v(" "),l("strong",[v._v("作业：整理自己的数据结构和脑图")])]),v._v(" "),l("h3",{attrs:{id:"数据结构"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),l("ul",[l("li",[v._v("排序\n"),l("ul",[l("li",[v._v("O（n^2)\n"),l("ul",[l("li",[v._v("冒泡排序")]),v._v(" "),l("li",[v._v("插入排序")]),v._v(" "),l("li",[v._v("选择排序")])])]),v._v(" "),l("li",[v._v("O（nlogn)\n"),l("ul",[l("li",[v._v("快速排序")]),v._v(" "),l("li",[v._v("归并排序")])])]),v._v(" "),l("li",[v._v("O（n)\n"),l("ul",[l("li",[v._v("桶排序")]),v._v(" "),l("li",[v._v("计数排序")]),v._v(" "),l("li",[v._v("基数排序")])])])])]),v._v(" "),l("li",[v._v("非受线性结构\n"),l("ul",[l("li",[v._v("顺序结构\n"),l("ul",[l("li",[v._v("数组\n"),l("ul",[l("li",[v._v("支持 O（1）的随机访问")]),v._v(" "),l("li",[v._v("平均为 O（n）的插入和删除")]),v._v(" "),l("li",[v._v("警惕越界错误，导致 Stack Over Flow")])])])])]),v._v(" "),l("li",[v._v("链式结构\n"),l("ul",[l("li",[v._v("单链表\n"),l("ul",[l("li",[v._v("不支持随机访问，需要遍历去访问节点")]),v._v(" "),l("li",[v._v("插入和删除只需要移动指针，时间复杂度为 O（1）")]),v._v(" "),l("li",[v._v("每个节点需要额外的存储指针，需要的内存比数据大")])])]),v._v(" "),l("li",[v._v("双链表\n"),l("ul",[l("li",[v._v("再单链表的基础上，除头节点外，每个节点多了一个存放前驱节点内存地址的指针")])])]),v._v(" "),l("li",[v._v("循环链表\n"),l("ul",[l("li",[v._v("尾节点指针指向头结点")])])]),v._v(" "),l("li",[v._v("静态链表\n"),l("ul",[l("li",[v._v("借助数组，伴随指向后继节点的指针")])])])])])])]),v._v(" "),l("li",[v._v("受限线性表\n"),l("ul",[l("li",[v._v("栈\n"),l("ul",[l("li",[v._v("顺序和链表都可以实现，先进后出")]),v._v(" "),l("li",[v._v("实际应用\n"),l("ul",[l("li",[v._v("浏览器的前进与后退")]),v._v(" "),l("li",[v._v("括号匹配")]),v._v(" "),l("li",[v._v("表达式运算")])])])])]),v._v(" "),l("li",[v._v("堆\n"),l("ul",[l("li",[v._v("大顶堆")]),v._v(" "),l("li",[v._v("小顶堆")]),v._v(" "),l("li",[v._v("实际应用\n"),l("ul",[l("li",[v._v("找第 K 大元素")])])])])]),v._v(" "),l("li",[v._v("队列\n"),l("ul",[l("li",[v._v("普通队列"),l("br"),v._v("\n顺序和链表都可以实现，先进先出")]),v._v(" "),l("li",[v._v("双边队列"),l("br"),v._v("\n入口和出口都可以进队和出队")]),v._v(" "),l("li",[v._v("优先级队列"),l("br"),v._v("\n根据优先级来出队")]),v._v(" "),l("li",[v._v("实际应用"),l("br"),v._v("\nLRU Cache")])])])])]),v._v(" "),l("li",[v._v("树与二叉树\n"),l("ul",[l("li",[v._v("特点\n"),l("ul",[l("li",[v._v("顺序和链式都可以实现")]),v._v(" "),l("li",[v._v("遍历方式\n"),l("ul",[l("li",[v._v("广度优先搜索")]),v._v(" "),l("li",[v._v("深度优先搜索\n"),l("ul",[l("li",[v._v("前序遍历")]),v._v(" "),l("li",[v._v("中序遍历")]),v._v(" "),l("li",[v._v("后续遍历")]),v._v(" "),l("li",[v._v("不使用递归的方式完成")])])])])])])]),v._v(" "),l("li",[v._v("二叉树\n"),l("ul",[l("li",[v._v("定义")]),v._v(" "),l("li",[v._v("特点")])])]),v._v(" "),l("li",[v._v("完全二叉树")]),v._v(" "),l("li",[v._v("满二叉树")]),v._v(" "),l("li",[v._v("二叉搜索树")]),v._v(" "),l("li",[v._v("平衡二叉树\n"),l("ul",[l("li",[v._v("红黑树")])])])])])]),v._v(" "),l("h3",{attrs:{id:"算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[v._v("#")]),v._v(" 算法")]),v._v(" "),l("ul",[l("li",[v._v("复杂度\n"),l("ul",[l("li",[v._v("时间复杂度\n"),l("ul",[l("li",[v._v("O（1）常数复杂度，最佳，比如 Hash 表，缓存等")]),v._v(" "),l("li",[v._v("O（log n）仅次与常数复杂度，如二分查找、二叉搜索树等")]),v._v(" "),l("li",[v._v("O（n）线性复杂度，如大多数遍历操作")]),v._v(" "),l("li",[v._v("O（n^2）双重 for 循环")]),v._v(" "),l("li",[v._v("O（2^n）递归的时间复杂度")])])]),v._v(" "),l("li",[v._v("空间复杂度\n"),l("ul",[l("li",[v._v("O（1）原地操作")]),v._v(" "),l("li",[v._v("O（n）开辟线性辅助空间")])])])])]),v._v(" "),l("li",[v._v("数组\n"),l("ul",[l("li",[v._v("连续空间")]),v._v(" "),l("li",[v._v("查找快、插入/删除 慢")])])]),v._v(" "),l("li",[v._v("链表\n"),l("ul",[l("li",[v._v("离散空间")]),v._v(" "),l("li",[v._v("查找慢，插入/删除节点快")])])]),v._v(" "),l("li",[v._v("栈\n"),l("ul",[l("li",[v._v("先进后出")])])]),v._v(" "),l("li",[v._v("队列\n"),l("ul",[l("li",[v._v("先进先出")])])]),v._v(" "),l("li",[v._v("映射")]),v._v(" "),l("li",[v._v("集合")]),v._v(" "),l("li",[v._v("并查集\n"),l("ul",[l("li",[v._v("站队问题")]),v._v(" "),l("li",[v._v("初始化")]),v._v(" "),l("li",[v._v("查询，合并")]),v._v(" "),l("li",[v._v("路径压缩")])])]),v._v(" "),l("li",[v._v("树\n"),l("ul",[l("li",[v._v("二叉树\n"),l("ul",[l("li",[v._v("遍历\n"),l("ul",[l("li",[v._v("DFS")]),v._v(" "),l("li",[v._v("BFS")])])]),v._v(" "),l("li",[v._v("二叉搜索树")]),v._v(" "),l("li",[v._v("平衡二叉树\n"),l("ul",[l("li",[v._v("AVL 树")]),v._v(" "),l("li",[v._v("红黑树")])])]),v._v(" "),l("li",[v._v("剪枝")])])]),v._v(" "),l("li",[v._v("字典树")])])]),v._v(" "),l("li",[v._v("递归，分治\n"),l("ul",[l("li",[v._v("盗梦空间")]),v._v(" "),l("li",[v._v("终止空间")]),v._v(" "),l("li",[v._v("本层处理")]),v._v(" "),l("li",[v._v("Drill Down")]),v._v(" "),l("li",[v._v("本层状态清理")])])]),v._v(" "),l("li",[v._v("二分查找\n"),l("ul",[l("li",[v._v("有序")]),v._v(" "),l("li",[v._v("有界")]),v._v(" "),l("li",[v._v("能够通过索引随机访问")])])]),v._v(" "),l("li",[v._v("贪心算法\n"),l("ul",[l("li",[v._v("判断能不能贪心")]),v._v(" "),l("li",[v._v("弱化版的动态规划")])])]),v._v(" "),l("li",[v._v("动态规划\n"),l("ul",[l("li",[v._v("简单版本是递归加缓存")]),v._v(" "),l("li",[v._v("高版本是地推公式")]),v._v(" "),l("li",[v._v("状态的定义\n"),l("ul",[l("li",[v._v("有的场景需要套用模板")])])]),v._v(" "),l("li",[v._v("最优子结构")]),v._v(" "),l("li",[v._v("状态转移方程")])])]),v._v(" "),l("li",[v._v("位运算\n"),l("ul",[l("li",[v._v("需要记忆一些常见的运算方式")])])]),v._v(" "),l("li",[v._v("布隆过滤器\n"),l("ul",[l("li",[v._v("判断不存在 100% 准确")]),v._v(" "),l("li",[v._v("判断存在误差")]),v._v(" "),l("li",[v._v("利用 Hash 函数将待判断 Key 对应的多个位上")])])]),v._v(" "),l("li",[v._v("LRU\n"),l("ul",[l("li",[v._v("HashTable + 双向链表")]),v._v(" "),l("li",[v._v("get 和 set 都是 O（1）的复杂度")])])])])])}),[],!1,null,null,null);_.default=n.exports}}]);