(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{332:function(t,e,s){t.exports=s.p+"assets/img/ICP.2b714a81.svg"},987:function(t,e,s){"use strict";s.r(e);var n=s(20),o=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),n("p",[t._v("接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。")]),t._v(" "),n("div",{staticClass:"custom-block warning"},[n("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),n("p",[t._v("2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。")])]),t._v(" "),n("p",[t._v("理解"),n("strong",[t._v("接口隔离原则")]),t._v("的重点是理解其中的"),n("strong",[t._v("接口")]),t._v("二字。这里有三种不同的理解。")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。")])]),t._v(" "),n("li",[n("p",[t._v("如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。")])]),t._v(" "),n("li",[n("p",[t._v("如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。")])])]),t._v(" "),n("p",[n("img",{staticClass:"lazy",attrs:{alt:"","data-src":s(332),loading:"lazy"}})])])}),[],!1,null,null,null);e.default=o.exports}}]);