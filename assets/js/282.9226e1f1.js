(window.webpackJsonp=window.webpackJsonp||[]).push([[282],{933:function(t,i,a){"use strict";a.r(i);var e=a(20),s=Object(e.a)({},(function(){var t=this,i=t.$createElement,a=t._self._c||i;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"什么是堆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是堆"}},[t._v("#")]),t._v(" 🔥 什么是堆❔")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("堆是一颗【"),a("strong",[t._v("完全二叉树")]),t._v("】")])]),t._v(" "),a("li",[a("p",[t._v("堆的所有【"),a("strong",[t._v("根节点")]),t._v("】“大于”【"),a("strong",[t._v("子节点")]),t._v("】")]),t._v(" "),a("p",[t._v("这里的大于是可以定义的。")])])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318211957067.png",alt:"image-20200318211957067"}}),t._v(" "),a("p",[t._v("​\t\t上图所示，都是满足堆上方的性质，一颗完全二叉树，所有的根节点大于子节点")]),t._v(" "),a("p",[t._v("​\t\t上方展示的为最大堆（相应的也可以定义最小堆）")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用数组表示")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318212734956.png",alt:"image-20200318212734956"}}),t._v(" "),a("p",[t._v("因为堆满足完全二叉树的定义，所以堆可以使用数组来表示【上图所示】。")]),t._v(" "),a("p",[t._v("由上图得在 index 位置上的节点可以推倒出如下公式 "),a("code",[t._v("parent(i) = i / 2")]),t._v(" "),a("code",[t._v("left child (i) = 2 * i")]),t._v(" "),a("code",[t._v("right child (i) = 2 * i + 1")])]),t._v(" "),a("p",[t._v("但是在上图中，其实是浪费了数组的零号位置，如果元素从0号位置排将会是下面的结构")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318213435336.png",alt:"image-20200318213435336"}}),t._v(" "),a("p",[t._v("由上图可以推倒公式为：")]),t._v(" "),a("p",[a("code",[t._v("parent(i) = (i - 1) / 2")]),t._v(" "),a("code",[t._v("left child (i) = 2 * i + 1")]),t._v(" "),a("code",[t._v("right child (i) = 2 * i + 2")])])])]),t._v(" "),a("h3",{attrs:{id:"堆中的常用操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆中的常用操作"}},[t._v("#")]),t._v(" 堆中的常用操作")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Sift Up （向堆中添加元素）")]),t._v(" "),a("p",[t._v("上浮，因为堆底层实现为数组，所以我们在添加元素的时候是直接向数组的末端添加元素，这样就始终保证堆是一个完全二叉树，但是我们需要维持二叉树第二个性质，根节点元素大于子节点，所以我们需要 sift up 操作")]),t._v(" "),a("p",[t._v("假设有如下堆结构：")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318214332416.png",alt:"image-20200318214332416"}}),t._v(" "),a("p",[t._v("假设我们现在需要添加的元素为 52，现在元素的位置为 "),a("code",[t._v("arr[arr.length - 1]")]),t._v("，但是这样就违反了堆的结构，因为 "),a("code",[t._v("52 > 16")]),t._v("，"),a("strong",[t._v("sift up 就是如果当前元素大于根节点元素的值那么就交换两个元素")]),t._v("，【迭代】执行，直到满足子节点小于根节点。")]),t._v(" "),a("p",[t._v("这时我们就需要交换 52 和 16号元素的值")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318214919048.png",alt:"image-20200318214919048"}}),t._v(" "),a("p",[t._v("交换完成后是这个样子")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318215227768.png",alt:"image-20200318215227768"}}),t._v(" "),a("p",[t._v("但是这时候又会发现还是不满足堆结构，因为 "),a("code",[t._v("52 > 41")]),t._v("，所以 52 和 41 还需要交换")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318215332914.png",alt:"image-20200318215332914"}}),t._v(" "),a("p",[t._v("交换后才又满足堆的结构")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318215450242.png",alt:"image-20200318215450242"}}),t._v(" "),a("p",[a("strong",[t._v("上面 52 号元素移动的整个过程，称之为 sift up 上浮")])]),t._v(" "),a("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/heap_sift_up.png"}})]),t._v(" "),a("li",[a("p",[t._v("Sift Down （取出堆中的最大元素）")]),t._v(" "),a("p",[t._v("由堆的特性所得，根节点的元素为堆中的最大元素，所以我们只需要取出根节点即可。")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318220445853.png",alt:"image-20200318220445853"}}),t._v(" "),a("p",[t._v("但是如果直接取出根节点就会导致将原来的堆切割为两个堆，后续在合并的时候就会变的异常麻烦，所以我们这里转变一下思路，直接将末尾的元素 arr[arr.length - 1] 16 与 根节点62 交换位置，而后再将其处理为堆结构这样会简单很多")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318220722116.png",alt:"image-20200318220722116"}}),t._v(" "),a("p",[t._v("如上图所示，直接将末尾的元素替换掉头结点。此时就违反了堆结构，我们就需要进行 Sift Down 的操作。")]),t._v(" "),a("p",[t._v("当前元素与它的左右孩子进行对比，与左右孩子中较大的孩子进行交换，迭代进行，最终便可完成 Sift Down")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318221110695.png",alt:"image-20200318221110695"}}),t._v(" "),a("p",[t._v("第一次交换 16 和 50 ，因为 52 > 30，交换后的效果为")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318221300114.png",alt:"image-20200318221300114"}}),t._v(" "),a("p",[t._v("第二次 交换 16 和 42，因为 42 > 16")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/image-20200318221601439.png",alt:"image-20200318221601439"}}),t._v(" "),a("p",[t._v("经过前面的两次交换后，现在就满足最大堆的性质了。")]),t._v(" "),a("p",[a("strong",[t._v("上面两次交换的过程就称为 Sift Down")])]),t._v(" "),a("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://gitee.com/xiaoxiunique/picgo-image/raw/master/atips/heap_sift_down.png"}})]),t._v(" "),a("li",[a("p",[t._v("replace")])]),t._v(" "),a("li",[a("p",[t._v("heapity")])])])])}),[],!1,null,null,null);i.default=s.exports}}]);